## Single responsibility Principle
==A class should have one, and only one reason to change== ~ by Robert
- Your class should have only one reason to change.
- Your method should have only one responsibility.

### Example
#### Incorrect way

```
 // Incorrect implementation of SRP  
	@RestController  
	@RequestMapping("/report")  
	public class ReportController {  
	  
		private final ReportService reportService;  
	  
	  
		public ReportController(ReportService reportService) {  
			this.reportService = reportService;  
		}  
	  
		@PostMapping("/send")  
		public ResponseEntity<Report> generateAndSendReport(
			@RequestParam String reportContent,  
			@RequestParam String to,  
			@RequestParam String subject) 
		{  
			String report = reportService.generateReport(reportContent);  
			reportService.sendReportByEmail(report, to, subject);  
			return new ResponseEntity<>(HttpStatus.OK);  
		}  
}
```

```
// Incorrect implementation of SRP  
// The class is responsible for generating a report and sending email  
@Service  
@Slf4j  
public class ReportServiceImpl implements ReportService {  
  
	private final ReportRepository reportRepository;  
  
	public ReportServiceImpl(ReportRepository reportRepository) {  
		this.reportRepository = reportRepository;  
	}  
	  
	@Override  
	public String generateReport(String reportContent) {  
		Report report = new Report();  
		report.setReportContent(reportContent);  
		return reportRepository.save(report).toString();  
	}  
	  
	@Override  
	public void sendReportByEmail(Long reportId, String to, String subject) {  
		Report report = findReportById(reportId);  
		sendEmail(report.getReportContent(), to, subject);  
	}  
	  
	private Report findReportById(Long reportId) {  
		return reportRepository.findById(reportId)  
			.orElseThrow(() -> new RuntimeException("Report not found"));  
	}  
	  
	private void sendEmail(String content, String to, String subject) {  
		log.info(content, to, subject);  
	}
}
```

### Correct way

```
@RestController  
@RequestMapping("/report")  
public class ReportController {  
  
	private final ReportService reportService;  
	private final EmailService emailService;  
  
	public ReportController(ReportService reportService, EmailService emailService) {  
		this.reportService = reportService;  
		this.emailService = emailService;  
	}  
	  
	@PostMapping("/send")  
	public ResponseEntity<Report> generateAndSendReport(
		@RequestParam String reportContent,  
		@RequestParam String to,  
		@RequestParam String subject)
	{  
		// correct impl reportService is responsible for generation  
		Long reportId = Long.valueOf(reportService.generateReport(reportContent));  
		// correct impl emailService is responsible for sending  
		emailService.sendReportByEmail(reportId, to, subject);  
		return new ResponseEntity<>(HttpStatus.OK);  
	}  
}
```

```
@Service  
public class ReportServiceImpl implements ReportService {  
  
	private final ReportRepository reportRepository;  
	  
	  
	public ReportServiceImpl(ReportRepository reportRepository, EmailService emailService) {  
	this.reportRepository = reportRepository;  
	}  
	  
	@Override  
	public String generateReport(String reportContent) {  
	Report report = new Report();  
	report.setReportContent(reportContent);  
	return reportRepository.save(report).toString();  
	}  
	  
	  
	@Service  
	public class EmailServiceImpl implements EmailService {  
	  
	private final ReportRepository reportRepository;  
	  
	public EmailServiceImpl(ReportRepository reportRepository) {  
		this.reportRepository = reportRepository;  
	}  
	  
	@Override  
	public void sendReportByEmail(Long reportId, String to, String subject) {  
		Report report = findReportById(reportId);  
		if (ObjectUtils.isEmpty(report) || !StringUtils.hasLength(report.getReportContent())) {  
			throw new RuntimeException("Report or report content is empty");  
		}  
	}  
	  
	private Report findReportById(Long reportId) {  
		return reportRepository.findById(reportId)  
		.orElseThrow(() -> new RuntimeException("Report not found"));  
	}  
  
}
```

The refactored code includes changes below;

- `ReportServiceImpl` is responsible for generating reports.
- `EmailServiceImpl` is responsible for sending reports -that were generated by `ReportServiceImpl-`by email.
- The `ReportController` manages the process of generating and sending reports by using the appropriate services.